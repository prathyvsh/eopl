* Chapter 2: Induction, Recursion, and Scope

The chapter begins by introducing the reader to Backus Naur Form and helping them reason about it with the help of exercises.

* Inductive Specification
A way to specify data types that are potentially infinite.

* Backus-Naur Form
** Syntactic Categories / Non-terminals

<list-of-numbers> ::= () | (<number>.<list-of-numbers>)

Using Kleene Star notation
<list-of-numbers> ::= ({<number>}*)

* Grammar
A grammar of a language describes using BNF the kind of structures possible to be
constructed with the help of it.

<list> ::= ({<datum>}*)
<dotted-datum> ::= ({<datum>}+ . <datum>)
<vector> ::= #({<datum>}*)
<datum> ::= <number> | <symbol> | <boolean> | <string> | <list> | <dotted-datum> | <vector>

* Exercise 2.1.2

This exercise is a good one in that it makes one think closely about the need for a dot syntax.
When the Kleene * and Kleene + is not used, the requirement for the dot syntax becomes apparent.

Without the dot syntax list ::= () | (<datum> <list>) would yield a nested structure. That is:

#+BEGIN_SRC
(<datum> (<datum> <list>))
(<datum> (<datum> ()))
#+END_SRC

Which is a recursively nested object, whereas with a dot notation, this nesting doesn't occur.

This exercise and the next one is also making me aware of the requirement for a null element
but this hasn't been taught in the textbook yet.

This object is required for the definition of <vector> without the Kleene star.

#+BEGIN_SRC
<vector> ::= #() | #(<datum> <vector>)
#+END_SRC

This would lead to the same problem as above. But a dot operator for <vector> doesn't seem to exist.

In the absence of this, the first solution that comes to my mind is to to introduce the null element.

* Exercise 2.1.3

The data structure (a . b . c) while not permissible with the grammar defined in the previous exercise seems like a 
valid data structure in Racket. [[https://stackoverflow.com/questions/7449865/scheme-lists-of-three-dotted-elements-returning-strangely-like-an-infix-operat][Stack Overflow]] reveals that it is a modification done on the reader that treats the . as an
infix operator.

* Context Free and Context Sensitive *
BNF notation is context free as a rule defining a given syntactic category may be applied in any context that makes reference to that syntactic category.
Context Sensitivity means that the state of the given context in which it is being applied matters. This is illustrated with the help of the syntactical construction of a binary search tree.

Context sensitivity also arises when a certain rule such as the declaration of an identifier before its use is required by the environment of evaluation.
Such constraints are said to be enforced with the help of formal methods. Since this often becomes cumbersome, this is added in using other methods.

Think this is a good point at which to refer how ambiguity can arise in a context free setting.

* Structural Recursion *
When defining a program based on structural induction, the structure of the program should be patterned after the structure of the data.


