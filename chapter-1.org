* Chapter 1

** Syntax
Rules governing how a programming language is formed

** Semantics
Rules that specify its meaning

** Section 1.1: Simple Expressions
Introduces several ways of building Scheme expressions.

*** Statement
A programming language construct that is evaluated only for its side effect.
Eg: Assignment, I/O statements, control statements.

*Expressions*: Programming language constructs that are evaluated to obtain values.

Expressions that are evaluated solely for their value, and not for any computational effects are said to be functional

*** 1.1.1 Literals, Procedure Calls, and Variables

**** Literals
They always return the expressed value.
Eg: Numbers, Booleans, Strings

**** Variable References

A value can be bound to a variable. This is its reference.

A variable is said to denote the value of its binding.

The data that can be bound to variables constitute the denoted values of a programming language.

In Scheme, the denoted values and expressed values are the same, at least in the absence of variable assignment.

In the book, the term function is reserved for mathematical functions and functions take on the name of procedure.

In the expression (p 2 3) the procedure p is said to be applied to the arguments 2 and 3.

This process of procedure call is known as application or combination.

An operation can have > 0 operands.

Operator and operands are components that are themselves expressions.

Expressions that are part of other expressions are called *subexpressions*.

The operator subexpression is evaluated to obtain a procedure, while operand subexpressions are evaluated to obtain the arguments of the call before invoking the procedure.

*Arguments* are also referred to as *actual parameters* or simply parameters.

In Scheme, the order in which operator and operand expressions are evaluated is not specified.

Procedures that return procedures are called higher-order procedures.

*** Special forms

Special forms are those in which the rules of evaluation are different than expression evaluation.

Special form identifiers are called *keywords*.

Each special form has its own sequencing rule, that is to say its own order of subexpression evaluation.

In the case of define, the expression is evaluated first and the variable is bound to the value of the expression.

The definitions and expressions are said to be at top level.

*** REPL = Read Eval Print Loop

The use of define is restricted to the top level in this book.

Redefinition of all variables is allowed in the Scheme environment in this book.

The distinction between the environment and the language is introduced early in this book.

*** Conditional Expressions

#+BEGIN_SRC :scheme
(if test-exp then-exp else-exp)
#+END_SRC

The use of if to guard against errors is only possible if it one of the branches is not evaluated as in the case of:

#+BEGIN_SRC :scheme
(if (zero? a) 0 (/ x a))
#+END_SRC

** Section 1.2
Data types

** Section 1.3
Procedures
